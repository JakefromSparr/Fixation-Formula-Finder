// script.js
let knownFormulas = []; // From data/knownFormulas.json (initial seed)
let catalogedFormulas = []; // Formulas user has classified (stored in localStorage)
let formulasToClassify = []; // Formulas generated by the system, awaiting user classification
let currentInteractiveConfig = []; // Formula being built manually by the user

let currentFormulaToClassifyIndex = 0; // Index for formulasToClassify list
let nextTileId = 0; // For unique ID assignment in interactive builder

// DOM Elements
const maxTilesDropdown = document.getElementById('maxTiles');
const runGenerationBtn = document.getElementById('runGeneration');
const resetBuilderBtn = document.getElementById('resetBuilder');
const undoLastMoveBtn = document.getElementById('undoLastMove');
const nextTileSelectionDiv = document.getElementById('nextTileSelection');
const selectPipDropdown = document.getElementById('selectPip');
const placeNextTileBtn = document.getElementById('placeNextTile');
const outputDisplay = document.getElementById('output');
const catalogSummaryDiv = document.getElementById('catalogSummary');
const catalogedFormulasList = document.getElementById('catalogedFormulasList');
const classificationMessage = document.getElementById('classificationMessage');
const classifyUniqueBtn = document.getElementById('classifyUnique');
const classifyDerivativeBtn = document.getElementById('classifyDerivative');
const classifyEchoBtn = document.getElementById('classifyEcho');
const exportUniqueBtn = document.getElementById('exportUnique');
// Ensure global set exists to track seen canonical forms across sessions
window.globalSeenConfigs = window.globalSeenConfigs || new Set();

// Track selected catalog formula for reclassification and whether we're in
// generated-formula classification mode
let selectedCatalogFormulaIndex = null;
let isClassifyingGenerated = false;


// --- Constants from game logic (re-declared here for self-containment of script.js) ---
const MAX_PIPS_PER_TYPE = 3; // Max 3 of each pip tile per player (total 6 for both players combined in a formula)
// `neighborDirs` is defined in validator.js and globally available, so avoid re-declaring it here.
// Ensure getDistance and other validator helpers are globally accessible (from validator.js)


// --- Data Persistence (localStorage) ---

const LS_KEY_CATALOGED = 'fixationFormulas_cataloged';
const LS_KEY_GENERATED_TO_CLASSIFY = 'fixationFormulas_generated_to_classify';
const LS_KEY_CURRENT_INTERACTIVE = 'fixationFormulas_current_interactive'; // Store interactive session

function saveToLocalStorage(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
}

function loadFromLocalStorage(key) {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
}

class FormulaRecord {
    constructor(config, validationResult, status, name = null) {
        this.config = config.map(t => ({
            id: t.id, q: t.q, r: t.r, pips: t.pips,
            connections: t.connections.map(c => ({ targetId: c.targetId }))
        }));
        this.result = validationResult;
        this.status = status;
        this.name = name;
        this.canonicalForm = getCanonicalForm(config);
    }
}

// --- Initialization ---

async function initializeApp() {
    await loadKnownFormulasSeed();
    loadCatalogedFormulas();
    loadFormulasToClassify();
    loadInteractiveSession();

    updateCatalogDisplay();
    updateUIForCurrentMode();
}

async function loadKnownFormulasSeed() {
    if (catalogedFormulas.length === 0) {
        try {
            const res = await fetch('data/knownFormulas.json');
            const seedData = await res.json();
            seedData.forEach(f => {
                f.status = f.status || "Known";
                f.canonicalForm = getCanonicalFormFromJSON(f);
            });
            catalogedFormulas.push(...seedData);
            saveToLocalStorage(LS_KEY_CATALOGED, catalogedFormulas);
        } catch (error) {
            console.error("Error loading initial known formulas seed:", error);
        }
    }
}

function getCanonicalFormFromJSON(formulaJson) {
    if (!formulaJson.config) {
        console.warn("Formula JSON does not contain 'config' data for canonicalization:", formulaJson);
        return formulaJson.valenceCode;
    }
    return getCanonicalForm(formulaJson.config.map(t => ({
        id: t.id, q: t.q, r: t.r, pips: t.pips, connections: t.connections
    })));
}

function loadCatalogedFormulas() {
    catalogedFormulas = loadFromLocalStorage(LS_KEY_CATALOGED) || [];
    window.globalSeenConfigs.clear();
    catalogedFormulas.forEach(f => {
        if (f.canonicalForm) {
            window.globalSeenConfigs.add(f.canonicalForm);
        }
    });
}

function loadFormulasToClassify() {
    formulasToClassify = loadFromLocalStorage(LS_KEY_GENERATED_TO_CLASSIFY) || [];
}

function loadInteractiveSession() {
    const savedSession = loadFromLocalStorage(LS_KEY_CURRENT_INTERACTIVE);
    if (savedSession && savedSession.config && savedSession.config.length > 0) {
        currentInteractiveConfig = savedSession.config.map(t => ({
            id: t.id, q: t.q, r: t.r, pips: t.pips,
            connections: t.connections.map(c => ({targetId: c.targetId})),
            currentBonds: t.currentBonds
        }));
        nextTileId = savedSession.nextTileId;
        updateBuilderUI();
        nextTileSelectionDiv.style.display = 'block';
        resetBuilderBtn.style.display = 'inline-block';
        undoLastMoveBtn.style.display = 'inline-block';
    } else {
        startNewInteractiveFormula();
    }
}


// --- Core Generator Logic (Constrained DFS) ---

function generateFormulasDFS() {
    formulasToClassify = [];
    saveToLocalStorage(LS_KEY_GENERATED_TO_CLASSIFY, formulasToClassify);

    for (const key in summary) delete summary[key];

    const currentMaxTiles = parseInt(maxTilesDropdown.value);
    outputDisplay.textContent = `Generating formulas up to ${currentMaxTiles} tiles...`;
    drawFormula([]);

    for (let startPip = 1; startPip <= 3; startPip++) {
        const initialConfig = [{
            id: 0, q: 0, r: 0, pips: startPip, connections: [], currentBonds: 0
        }];
        const initialAvailablePips = { 1: MAX_PIPS_PER_TYPE, 2: MAX_PIPS_PER_TYPE, 3: MAX_PIPS_PER_TYPE };
        initialAvailablePips[startPip]--;

        if (initialAvailablePips[startPip] >= 0) {
            recurseGenerate(initialConfig, initialAvailablePips, currentMaxTiles);
        }
    }
    if (formulasToClassify.length > 0) {
        currentFormulaToClassifyIndex = 0;
        showFormulaToClassify();
    } else {
        outputDisplay.textContent = `No new formulas found up to ${currentMaxTiles} tiles that require classification.`;
        classificationMessage.textContent = "";
        hideClassificationControls();
    }

    console.log("\n--- Aggregated Shape Summary from Generation ---");
    window.printSummary();
}

function recurseGenerate(currentConfig, availablePips, maxDepth) {
    const configCopy = JSON.parse(JSON.stringify(currentConfig));
    const availablePipsCopy = { ...availablePips };

    const bondedConfig = attemptAllPossibleBonds(configCopy);

    if (bondedConfig === null) {
        return;
    }
    configCopy.splice(0, configCopy.length, ...bondedConfig);

    const isFormulaComplete = configCopy.every(t => t.currentBonds === t.pips);
    const isValidOverall = isValidPipSum(configCopy) && isGeometricallyValid(configCopy);

    if (isFormulaComplete && isValidOverall) {
        const canonicalForm = getCanonicalForm(configCopy);

        if (!window.globalSeenConfigs.has(canonicalForm)) {
            const result = validateFormula(configCopy);
            formulasToClassify.push(new FormulaRecord(configCopy, result, "Pending Classification"));
            saveToLocalStorage(LS_KEY_GENERATED_TO_CLASSIFY, formulasToClassify);
        }
        return;
    }

    if (configCopy.length >= maxDepth) {
        return;
    }
    const totalAvailablePipsCount = Object.values(availablePipsCopy).reduce((sum, count) => sum + count, 0);
    const totalUnsatisfiedPipsInConfig = configCopy.reduce((sum, tile) => sum + (tile.pips - tile.currentBonds), 0);

    if (totalAvailablePipsCount === 0 && totalUnsatisfiedPipsInConfig > 0) {
        return;
    }
    if ((totalUnsatisfiedPipsInConfig + totalAvailablePipsCount) % 2 !== 0) {
        return;
    }

    const potentialPlacementSpots = calculateViablePlacementSpots(configCopy);

    for (let newPipValue = 1; newPipValue <= 3; newPipValue++) {
        if (availablePipsCopy[newPipValue] > 0) {
            for (const spot of potentialPlacementSpots) {
                const dummySelectedTile = { pips: newPipValue, remainingPips: newPipValue };

                const isSpotViableInGameLogic = checkIfSpotMeetsGamePlacementRules(
                    configCopy, spot.q, spot.r, dummySelectedTile
                );

                if (!isSpotViableInGameLogic) {
                    continue;
                }

                const newTile = {
                    id: configCopy.length,
                    q: spot.q, r: spot.r,
                    pips: newPipValue,
                    connections: [],
                    currentBonds: 0
                };

                const nextConfig = JSON.parse(JSON.stringify(configCopy));
                const nextAvailablePips = { ...availablePipsCopy };

                nextConfig.push(newTile);
                nextAvailablePips[newPipValue]--;

                recurseGenerate(nextConfig, nextAvailablePips, maxDepth);
            }
        }
    }
}

// This helper implements the game's placement rules for a single proposed spot
// using the logic from the original Fixation prototype. It checks that a tile
// placed at (proposedQ, proposedR) would be adjacent to at least one neighbour
// with free bond capacity and not next to fully bonded tiles only.
function checkIfSpotMeetsGamePlacementRules(currentConfig, proposedQ, proposedR, selectedTileDetails) {
    const boardMap = new Map();
    currentConfig.forEach(t => boardMap.set(`${t.q},${t.r}`, t));

    let openPipNeighbors = 0;
    let zeroPipNeighbor = false;
    const neighbors = neighborDirs.map(d => ({ q: proposedQ + d.q, r: proposedR + d.r }));

    for (const n of neighbors) {
        const tile = boardMap.get(`${n.q},${n.r}`);
        if (!tile) continue;
        if (tile.currentBonds < tile.pips) {
            openPipNeighbors++;
        } else if (tile.currentBonds === tile.pips) {
            zeroPipNeighbor = true;
        }
    }

    return (
        selectedTileDetails.pips > 0 &&
        openPipNeighbors >= 1 &&
        !zeroPipNeighbor
    );
}

// Attempts to satisfy all possible bonds between adjacent tiles. Returns a new
// configuration with updated `currentBonds` and `connections` or `null` if a
// bond would exceed a tile's pip capacity.
function attemptAllPossibleBonds(config) {
    const working = JSON.parse(JSON.stringify(config));
    let madeBond;
    do {
        madeBond = false;
        for (let i = 0; i < working.length; i++) {
            const t1 = working[i];
            if (t1.currentBonds >= t1.pips) continue;
            for (let j = i + 1; j < working.length; j++) {
                const t2 = working[j];
                if (t2.currentBonds >= t2.pips) continue;
                if (getDistance(t1, t2) === 1 && !t1.connections.some(c => c.targetId === t2.id)) {
                    if (t1.currentBonds < t1.pips && t2.currentBonds < t2.pips) {
                        t1.connections.push({ targetId: t2.id });
                        t1.currentBonds++;
                        t2.connections.push({ targetId: t1.id });
                        t2.currentBonds++;
                        madeBond = true;
                        if (t1.currentBonds > t1.pips || t2.currentBonds > t2.pips) {
                            return null;
                        }
                    }
                }
            }
        }
    } while (madeBond);

    return working;
}


// --- Interactive Formula Builder Logic ---

function startNewInteractiveFormula() {
    currentInteractiveConfig = [];
    nextTileId = 0;
    selectPipDropdown.value = '1';

    isClassifyingGenerated = false;

    nextTileSelectionDiv.style.display = 'block';
    undoLastMoveBtn.style.display = 'none';
    hideClassificationControls();
    outputDisplay.textContent = "Click 'Place Tile' to add the first tile (at 0,0).";
    drawFormula([]);
    saveToLocalStorage(LS_KEY_CURRENT_INTERACTIVE, { config: currentInteractiveConfig, nextTileId });
    updateBuilderUI();
}

function placeNextTileInteractive() {
    const pipsToPlace = parseInt(selectPipDropdown.value);

    let spotToPlace;
    if (currentInteractiveConfig.length === 0) {
        spotToPlace = { q: 0, r: 0 };
    } else {
        const viableSpots = calculateViablePlacementSpots(currentInteractiveConfig);
        if (viableSpots.length === 0) {
            outputDisplay.textContent = "No empty adjacent spots available for placement. Try a different pip or 'Start New Formula'.";
            return;
        }

        const dummySelectedTile = { pips: pipsToPlace, remainingPips: pipsToPlace };
        spotToPlace = null;
        for (const spot of viableSpots) {
            if (checkIfSpotMeetsGamePlacementRules(currentInteractiveConfig, spot.q, spot.r, dummySelectedTile)) {
                spotToPlace = spot;
                break;
            }
        }
        if (!spotToPlace) {
            outputDisplay.textContent = `No viable spot found for a ${pipsToPlace}-pip tile by game rules.`;
            return;
        }
    }

    const newTile = {
        id: nextTileId, q: spotToPlace.q, r: spotToPlace.r,
        pips: pipsToPlace, connections: [], currentBonds: 0
    };

    const tempConfig = JSON.parse(JSON.stringify(currentInteractiveConfig));
    tempConfig.push(newTile);

    const bondedConfig = attemptAllPossibleBonds(tempConfig);

    if (bondedConfig === null) {
        outputDisplay.textContent = "Placement leads to an invalid bonding state (e.g., exceeding pips). Undo or try different pip.";
        return;
    }

    currentInteractiveConfig = bondedConfig;
    nextTileId++;
    saveToLocalStorage(LS_KEY_CURRENT_INTERACTIVE, { config: currentInteractiveConfig, nextTileId });
    updateBuilderUI();
}

function undoLastMoveInteractive() {
    if (currentInteractiveConfig.length === 0) return;

    currentInteractiveConfig.pop();
    nextTileId--;

    const reBondedConfig = attemptAllPossibleBonds(JSON.parse(JSON.stringify(currentInteractiveConfig)));

    if (reBondedConfig === null) {
        console.error("Undo led to an invalid state during re-bonding.");
        startNewInteractiveFormula();
        return;
    }
    currentInteractiveConfig = reBondedConfig;

    saveToLocalStorage(LS_KEY_CURRENT_INTERACTIVE, { config: currentInteractiveConfig, nextTileId });
    updateBuilderUI();
}


function updateBuilderUI() {
    drawFormula(currentInteractiveConfig);

    const validationResult = validateFormula(currentInteractiveConfig);
    outputDisplay.textContent = JSON.stringify(validationResult, null, 2);

    undoLastMoveBtn.style.display = currentInteractiveConfig.length > 0 ? 'inline-block' : 'none';

    if (validationResult.isValid && validationResult.isComplete) {
        const canonical = getCanonicalForm(currentInteractiveConfig);
        const alreadyCataloged = catalogedFormulas.some(f => f.canonicalForm === canonical);

        if (alreadyCataloged) {
            classificationMessage.textContent = `Formula already cataloged as ${catalogedFormulas.find(f=>f.canonicalForm===canonical).status}.`;
            hideClassificationControls();
        } else {
            classificationMessage.textContent = "Formula Complete! Classify it:";
            classifyUniqueBtn.style.display = 'inline-block';
            classifyDerivativeBtn.style.display = 'inline-block';
            classifyEchoBtn.style.display = 'inline-block';
        }
    } else {
        classificationMessage.textContent = "Building Formula...";
        hideClassificationControls();
    }
}

function hideClassificationControls() {
    classifyUniqueBtn.style.display = 'none';
    classifyDerivativeBtn.style.display = 'none';
    classifyEchoBtn.style.display = 'none';
    selectedCatalogFormulaIndex = null;
}

function updateUIForCurrentMode() {
    updateBuilderUI();
}


// --- Formula Classification Actions ---

function classifyInteractiveFormula(status) {
    const currentValidation = validateFormula(currentInteractiveConfig);
    if (!currentValidation.isValid || !currentValidation.isComplete) {
        alert("Current formula is not valid or complete. Cannot classify.");
        return;
    }

    let formulaName = null;
    if (status === "Unique") {
        formulaName = prompt("Enter a name for this UNIQUE formula (e.g., 'The Coil'):");
        if (!formulaName) {
            alert("Unique formulas must have a name.");
            return;
        }
    } else if (status === "Derivative") {
        formulaName = prompt("Enter a name for this DERIVATIVE formula (optional):");
    }

    const newFormulaRecord = new FormulaRecord(
        currentInteractiveConfig,
        currentValidation,
        status,
        formulaName
    );

    catalogedFormulas.push(newFormulaRecord);
    saveToLocalStorage(LS_KEY_CATALOGED, catalogedFormulas);
    window.globalSeenConfigs.add(newFormulaRecord.canonicalForm);

    updateCatalogDisplay();

    alert(`Formula classified as ${status}!`);
    startNewInteractiveFormula();
}

// Classify a formula generated automatically (from the queue)
function classifyGeneratedFormula(status) {
    const item = formulasToClassify[currentFormulaToClassifyIndex];

    let formulaName = item.name || null;
    if (status === "Unique") {
        formulaName = prompt("Enter a name for this UNIQUE formula (e.g., 'The Coil'):", formulaName || "");
        if (!formulaName) {
            alert("Unique formulas must have a name.");
            return;
        }
    } else if (status === "Derivative") {
        const maybe = prompt("Enter a name for this DERIVATIVE formula (optional):", formulaName || "");
        if (maybe) formulaName = maybe;
    }

    item.status = status;
    item.name = formulaName;

    catalogedFormulas.push(item);
    window.globalSeenConfigs.add(item.canonicalForm);
    formulasToClassify.splice(currentFormulaToClassifyIndex, 1);
    if (currentFormulaToClassifyIndex >= formulasToClassify.length) currentFormulaToClassifyIndex = 0;

    saveToLocalStorage(LS_KEY_CATALOGED, catalogedFormulas);
    saveToLocalStorage(LS_KEY_GENERATED_TO_CLASSIFY, formulasToClassify);
    updateCatalogDisplay();
    showFormulaToClassify();
}

// Change classification of an already cataloged formula
function changeClassification(status) {
    if (selectedCatalogFormulaIndex === null) return;
    const record = catalogedFormulas[selectedCatalogFormulaIndex];
    let formulaName = record.name || null;

    if (status === "Unique") {
        formulaName = prompt("Enter a name for this UNIQUE formula:", formulaName || "");
        if (!formulaName) {
            alert("Unique formulas must have a name.");
            return;
        }
    } else if (status === "Derivative") {
        const maybe = prompt("Enter a name for this DERIVATIVE formula (optional):", formulaName || "");
        if (maybe) formulaName = maybe;
    }

    record.status = status;
    record.name = formulaName;
    saveToLocalStorage(LS_KEY_CATALOGED, catalogedFormulas);
    updateCatalogDisplay();
    classificationMessage.textContent = `Updated classification to ${status}.`;
    hideClassificationControls();
    selectedCatalogFormulaIndex = null;
}

function handleClassification(status) {
    if (selectedCatalogFormulaIndex !== null) {
        changeClassification(status);
    } else if (isClassifyingGenerated) {
        classifyGeneratedFormula(status);
    } else {
        classifyInteractiveFormula(status);
    }
}

function exportUniqueFormulas() {
    const unique = catalogedFormulas.filter(f => f.status === 'Unique');
    const json = JSON.stringify(unique, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'uniqueFormulas.json';
    a.click();
    URL.revokeObjectURL(url);
}

// --- Display of Cataloged Formulas ---

function updateCatalogDisplay() {
    catalogedFormulasList.innerHTML = '';
    catalogSummaryDiv.innerHTML = '';

    if (catalogedFormulas.length === 0) {
        catalogedFormulasList.innerHTML = '<p>No formulas cataloged yet.</p>';
        return;
    }

    const counts = { Unique: 0, Derivative: 0, Echo: 0, Known: 0, "Pending Classification": 0 };
    catalogedFormulas.forEach(f => {
        counts[f.status]++;
    });
    catalogSummaryDiv.innerHTML = `
        <p>Unique: ${counts.Unique}</p>
        <p>Derivative: ${counts.Derivative}</p>
        <p>Echo: ${counts.Echo}</p>
        <p>Known (Seed): ${counts.Known}</p>
    `;

    catalogedFormulas.sort((a,b) => {
        if (a.status !== b.status) return a.status.localeCompare(b.status);
        if (a.result.totalTiles !== b.result.totalTiles) return a.result.totalTiles - b.result.totalTiles;
        return a.valenceCode.localeCompare(b.valenceCode);
    });

    catalogedFormulas.forEach(record => {
        const li = document.createElement('li');
        let displayText = record.name || record.result.shapeType;
        if (record.status !== "Unique") {
            displayText += ` (${record.status})`;
        }
        displayText += ` (${record.result.pipDistribution})`;
        
        li.textContent = displayText;
        li.title = record.description || `Status: ${record.status}`;

        if (record.status === "Unique") li.style.backgroundColor = '#d4edda';
        else if (record.status === "Derivative") li.style.backgroundColor = '#fff3cd';
        else if (record.status === "Echo") li.style.backgroundColor = '#f8d7da';
        else if (record.status === "Known") li.style.backgroundColor = '#e2f0f8';

        li.addEventListener('click', () => {
            drawFormula(record.config.map(t => ({
                id: t.id, q: t.q, r: t.r, pips: t.pips, connections: t.connections
            })));
            outputDisplay.textContent = JSON.stringify(record, null, 2);
            classificationMessage.textContent = `Viewing cataloged: ${record.name || record.status}`;
            selectedCatalogFormulaIndex = catalogedFormulas.indexOf(record);
            isClassifyingGenerated = false;
            classifyUniqueBtn.style.display = 'inline-block';
            classifyDerivativeBtn.style.display = 'inline-block';
            classifyEchoBtn.style.display = 'inline-block';
        });
        catalogedFormulasList.appendChild(li);
    });
}

// --- Navigation of Generated Formulas (for Classification Queue) ---

function showFormulaToClassify() {
    if (formulasToClassify.length === 0) {
        outputDisplay.textContent = "No more generated formulas to classify. Run generation again!";
        classificationMessage.textContent = "";
        drawFormula([]);
        hideClassificationControls();
        isClassifyingGenerated = false;
        return;
    }
    const item = formulasToClassify[currentFormulaToClassifyIndex];
    outputDisplay.textContent = JSON.stringify(item.result, null, 2);
    drawFormula(item.config);

    classificationMessage.textContent = `Formula ${currentFormulaToClassifyIndex + 1} of ${formulasToClassify.length} (Pip: ${item.result.pipDistribution}, Shape: ${item.result.shapeType})`;
    classifyUniqueBtn.style.display = 'inline-block';
    classifyDerivativeBtn.style.display = 'inline-block';
    classifyEchoBtn.style.display = 'inline-block';
    isClassifyingGenerated = true;
}

function nextFormulaToClassify() {
    currentFormulaToClassifyIndex++;
    if (currentFormulaToClassifyIndex >= formulasToClassify.length) {
        currentFormulaToClassifyIndex = 0;
    }
    showFormulaToClassify();
}

function prevFormulaToClassify() {
    currentFormulaToClassifyIndex--;
    if (currentFormulaToClassifyIndex < 0) {
        currentFormulaToClassifyIndex = formulasToClassify.length - 1;
    }
    showFormulaToClassify();
}


// --- Event Listeners ---
runGenerationBtn.addEventListener('click', generateFormulasDFS);
resetBuilderBtn.addEventListener('click', startNewInteractiveFormula);
placeNextTileBtn.addEventListener('click', placeNextTileInteractive);
undoLastMoveBtn.addEventListener('click', undoLastMoveInteractive);

classifyUniqueBtn.addEventListener('click', () => handleClassification("Unique"));
classifyDerivativeBtn.addEventListener('click', () => handleClassification("Derivative"));
classifyEchoBtn.addEventListener('click', () => handleClassification("Echo"));


document.getElementById('nextVis').addEventListener('click', nextFormulaToClassify);
document.getElementById('prevVis').addEventListener('click', prevFormulaToClassify);
exportUniqueBtn.addEventListener('click', exportUniqueFormulas);

initializeApp();
